<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桥</title>
  
  <subtitle>时间未动，动的是我们</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-22T11:51:47.667Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://yoursite.com/2018/03/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/22/java多线程/</id>
    <published>2018-03-22T11:46:05.426Z</published>
    <updated>2018-03-22T11:51:47.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ol><li>新建状态:<br>&ensp;&ensp;&ensp;&ensp;顾名思义，就是新建一个线程。处于新建状态的线程有自己的内存空间，通过调用start方法进入就绪状态。<a id="more"></a></li><li>就绪状态:<br>&ensp;&ensp;&ensp;&ensp;这时已经具备了运行条件，但还没有分配到CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</li><li>运行状态:<br>&ensp;&ensp;&ensp;&ensp;运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。<br>&ensp;&ensp;&ensp;&ensp;此时线程失去了cpu资源，就会又从运行状态变为就绪状态。当发生如下情况是，线程会从运行状态变为阻塞状态：<br>①、线程调用sleep方法主动放弃所占用的系统资源<br>②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞<br>③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有<br>④、线程在等待某个通知（notify）<br>⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。<br>当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。</li><li>阻塞状态：<br>&ensp;&ensp;&ensp;&ensp;在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</li><li>死亡状态：<br>&ensp;&ensp;&ensp;&ensp;当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li></ol><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><p>java中实现多线程的方式有四种：<br>     &ensp;&ensp;1. 继承Thread类，重写run方法<br>     &ensp;&ensp;2. 实现Runnable接口，重写run方法。<br>     &ensp;&ensp;3. 通过Callable和FutureTask创建线程。<br>     &ensp;&ensp;4. 通过线程池创建线程<br> &ensp;&ensp;前两种可以归为一类，都是通过重写run方法，run方法的返回类型为void，无返回值。由于java单继承，类继承了Thread，会导致无法继承其他类，同时继承Thread类实际上是无法达到资源共享的目的的，所以在实际开发中更多的是实现Runnable接口。后面两种有返回值可以归结为一类。<br><br><br> 方法1：继承Thread类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.thread;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 继承Thread类</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午11:06 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    volatile int i ;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (; i &lt; 10 ; i ++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;执行了第&quot;+i+&quot;次&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        ThreadTest threadTest = new ThreadTest();</span><br><span class="line">        ThreadTest threadTest1 = new ThreadTest();</span><br><span class="line">        ThreadTest threadTest2 = new ThreadTest();</span><br><span class="line">        ThreadTest threadTest3 = new ThreadTest();</span><br><span class="line">        threadTest.start();</span><br><span class="line">        threadTest1.start();</span><br><span class="line">        threadTest2.start();</span><br><span class="line">        threadTest3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：实现Runnable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.runnable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 实现runnable接口</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午10:56 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class RunnableTest implements Runnable&#123;</span><br><span class="line">    int i;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (; i &lt; 10 ; i ++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行了第&quot;+i+&quot;次&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        RunnableTest runnableTest = new RunnableTest();</span><br><span class="line">        Thread thread = new Thread(runnableTest,&quot;线程&quot;);</span><br><span class="line">        Thread thread1 = new Thread(runnableTest,&quot;线程1&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：实现Callable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.callable;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 实现callable接口</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午11:09 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class CallableTest implements Callable &#123;</span><br><span class="line"></span><br><span class="line">    int i ;</span><br><span class="line"></span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        for (; i &lt; 10 ; i ++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行了第&quot;+i+&quot;次&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Thread.currentThread().getName()+&quot;执行完毕&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        CallableTest callableTest = new CallableTest();</span><br><span class="line">        FutureTask futureTask = new FutureTask(callableTest);</span><br><span class="line">        FutureTask futureTask1 = new FutureTask(callableTest);</span><br><span class="line">        new Thread(futureTask,&quot;aa&quot;).start();</span><br><span class="line">        new Thread(futureTask1,&quot;bb&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">            System.out.println(futureTask1.get());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.ThreadPool;</span><br><span class="line"></span><br><span class="line">import com.zhang.Thread.callable.CallableTest;</span><br><span class="line">import com.zhang.Thread.runnable.RunnableTest;</span><br><span class="line">import com.zhang.Thread.thread.ThreadTest;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 线程池</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午10:55 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line"></span><br><span class="line">    static ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        //官方推荐，会自动创建 销毁</span><br><span class="line">        executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(new ThreadTest());</span><br><span class="line">        executorService.execute(new RunnableTest());</span><br><span class="line">        FutureTask futureTask = new FutureTask(new CallableTest());</span><br><span class="line">        executorService.execute(futureTask);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //关闭</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;执行后会发现结果有时候会和自己想的有些差别，这就是线程不安全的问题。下一篇会详解一下线程安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程生命周期&quot;&gt;&lt;a href=&quot;#线程生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程生命周期&quot;&gt;&lt;/a&gt;线程生命周期&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建状态:&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;顾名思义，就是新建一个线程。处于新建状态的线程有自己的内存空间，通过调用start方法进入就绪状态。
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2018/03/21/java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/21/java代理模式/</id>
    <published>2018-03-21T08:13:33.753Z</published>
    <updated>2018-03-23T05:41:36.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><p>&emsp;&emsp;代理（Proxy）是一种常用的设计模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。目的就是在不需要修改原有的代码情况下扩展原功能。<br><a id="more"></a></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>1.创建服务类接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public interface UserInterface &#123;</span><br><span class="line"></span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.实现服务接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class UserImpl implements UserInterface&#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;执行User的save方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class UserProxy implements UserInterface &#123;</span><br><span class="line">    private UserImpl target;</span><br><span class="line">    public UserProxy(UserImpl target) &#123;</span><br><span class="line">        this.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;开始执行代理类&quot;);</span><br><span class="line">        target.save();</span><br><span class="line">        System.out.println(&quot;结束执行代理类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.可以来测试啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        UserImpl user = new UserImpl();</span><br><span class="line">        UserProxy userProxy = new UserProxy(user);</span><br><span class="line">        userProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理总结：<br>&emsp;&emsp;可以做到不修改原服务代码的情况下对目标对象进行功能的扩展，但为们需要为每一个服务都创建一个代理类，工作量有些大，同时接口发生改变，代理类也需要改变。<br><br></p><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>&emsp;&emsp;在动态代理中我们只需要写一个动态处理器。JDK运行时为我们动态创建代理对象。<br>1.创建目标对象接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.创建目标对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;执行UserServiceImpl的add方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.编写jdk动态处理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : jdk动态代理</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 下午4:13 2018/3/19</span><br><span class="line"> */</span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行目标对象方法</span><br><span class="line">     * @param proxy</span><br><span class="line">     * @param method</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行目标方法前&quot;);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;执行目标方法后&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取目标对象的代理对象</span><br><span class="line">     * @return 代理对象</span><br><span class="line">     */</span><br><span class="line">    public Object getProxy() &#123;</span><br><span class="line">        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                this.target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.编写测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_02 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //实例化目标对象</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        //实例化Invocation</span><br><span class="line">        MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);</span><br><span class="line">        //根据目标生成代理对象</span><br><span class="line">        UserService proxy = (UserService) invocationHandler.getProxy();</span><br><span class="line">        //调用代理对象方法</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance()方法接受的三个参数：<br>&emsp;&emsp;1.当前目标对象使用的类加载器<br>&emsp;&emsp;2.制定目标对象实现的接口类型<br>&emsp;&emsp;3.指定动态处理器，执行目标对象时触发处理器的方法<br>jdk动态代理总结：<br>&emsp;&emsp;对比静态代理，动态代理减少了为们开发任务，同时降低了对接口的耦合度。遗憾的是只能对实现了接口的类进行代理。</p><h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p>&emsp;&emsp;由于Jdk动态代理只能对实现了接口的类进行代理。那么对于没有接口的类，就需要cglib了。<br>1.引入jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.创建目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;执行User的add方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.创建cglib代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class UserCglib implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line">    /**</span><br><span class="line">     * 创建代理对象</span><br><span class="line">     * @param target</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object getInstance(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">      enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        //回调方法</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 回调方法</span><br><span class="line">     * @param o</span><br><span class="line">     * @param method</span><br><span class="line">     * @param objects</span><br><span class="line">     * @param methodProxy</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行目标方法之前&quot;);</span><br><span class="line">        methodProxy.invokeSuper(o,objects);</span><br><span class="line">        System.out.println(&quot;执行目标方法之后&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        UserCglib userCglib = new UserCglib();</span><br><span class="line">        User user = (User)userCglib.getInstance(new User());</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cglib代理总结：<br>&emsp;&emsp;cglib创建的动态代理对象比JDK创建的性能更高，代价是创建时花费的时间也多的多。所以对于单例对象，采用cglib更合适。cglib采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p><h2 id="拓展Spring-aop"><a href="#拓展Spring-aop" class="headerlink" title="拓展Spring aop"></a>拓展Spring aop</h2><p>&emsp;&emsp;Spring 默认采用JDK动态代理，如果要被代理的对象不是实现类，那么Spring会强制使用CGLib来实现动态代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- 切面详细配置 --&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></p><p>target=true为cglib代理。默认为false</p>]]></content>
    
    <summary type="html">
    
      本文将介绍代理模式的几种实现方式，以及每种方式的优缺点。同时拓展了Spring Aop
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
