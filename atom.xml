<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桥</title>
  
  <subtitle>时间未动，动的是我们</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-28T01:24:24.831Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java垃圾回收（GC）机制</title>
    <link href="http://yoursite.com/2018/04/28/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/28/java垃圾回收机制（GC）/</id>
    <published>2018-04-28T01:24:21.680Z</published>
    <updated>2018-04-28T01:24:24.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要垃圾回收？"><a href="#为什么需要垃圾回收？" class="headerlink" title="为什么需要垃圾回收？"></a>为什么需要垃圾回收？</h1><p>&nbsp;&nbsp;我们的内存是有限的，如果不进行垃圾回收，程序不断的运行，会创建大量的对象从而把内存消耗空，导致内存不足。</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p> &nbsp;&nbsp;引用计数法是早期的垃圾回收算法，目前很多的java版本已经放弃了这种算法。它的使用是给每个对象分配一个计数器，当有引用指向这个对象时，计数器加1，引用失效时，计数器减1.如果计数器为0时，则java垃圾回收器则认为这个对象可以回收。<br> &nbsp;&nbsp;它的优点便是它的实时性，不需要等到内存不够了才回收，可以根据运行时对象的计数器是否为0，对对象进行回收；回收的过程中应用也无需挂起，更新对象只影响该对象，不会扫描全部对象。<br> &nbsp;&nbsp;缺点是每次引用对象都需要去更新计数器，循环引用问题也无法解决；浪费cpu。</p><h2 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h2><p> &nbsp;&nbsp;标记-清除法是java垃圾回收机制的另一个基本算法。标记-清除法有两个阶段。</p><ol><li>标记阶段：找到所有可访问的对象，做个标记。</li><li>清除阶段：遍历堆，把未标记的对象回收。<br>其中可访问对象的定义为：如果栈中有一个变量a引用了一个对象，则该对象为可访问对象，如果该对象中的某一个字段引用了另外一个对象b，则b也是可访问的。<br>&nbsp;&nbsp;它的优点，可以解决循环引用的问题，必要时才回收。<br>&nbsp;&nbsp;它的缺点，回收的时候应用需要挂起，标记和清除的效率不高，会造成内存碎片。</li></ol><h2 id="复制法"><a href="#复制法" class="headerlink" title="复制法"></a>复制法</h2><p>&nbsp;&nbsp;复制法时为了解决标记清除法的缺陷提出来的，它讲内存分为大小相等的两块，每次只用其中的一块，当这块用完了，就将存活的对象复制到另外一块上，然后把这块内存一次清理掉，这样就不会有内存碎片的问题。<br>&nbsp;&nbsp;它的优点：实现简单，运行效率高，解决了内存碎片问题。<br>&nbsp;&nbsp;它的缺点：内存的使用只有原来的一半。</p><h2 id="标记-整理法"><a href="#标记-整理法" class="headerlink" title="标记-整理法"></a>标记-整理法</h2><p>&nbsp;&nbsp;标记整理法是为了解决复制法的缺陷提出来的，它充分利用了内存空间，它和复制法一样，但是在完成标记之后，它并不直接清理可回收对象，而是将存活的对象都向另一端移动，然后清理掉边界以外的内存。<br>&nbsp;&nbsp;它的优点：解决了复制法内存只有一半的缺陷。<br>&nbsp;&nbsp;它的缺点：在对象存活率较高的情况下要执行较多的复制操作，效率低。</p><h2 id="分代收集法"><a href="#分代收集法" class="headerlink" title="分代收集法"></a>分代收集法</h2><p> &nbsp;&nbsp;分代收集法是目前大部分JVM垃圾回收器采用的算法。一般情况下它把堆区划分为新生代和老年代以及堆区之外的永久代。<br> &nbsp;&nbsp;新生代的特点是每次回收时都会有大量的对象被回收，老年代的特点是每次回收时只有少量对象被回收，这样就可以根据不同代的特点来进行适合的算法。对于新生代一般采用复制法，而老年代一般采用标记-整理法，而永久代存储class类、常量、方法描述等，对永久代来说一般回收两部分：废弃常量和无用的类。<br> &nbsp;&nbsp;新生代转到老年代：新生代垃圾回收的复制法，内存空间不再按1:1进行分配，而是按照内存分为一块较大的Eden空间和两块较小的Survivor空间，一般默认比例为8:1:1（可以通过-XX:SurivorRatio=i来设置，默认i为8），每次使用Eden和其中的一个Survivor。当回收时，将Eden和其中一块Surivivor中还存活的对象一次性复制到另外一块Survivor中，然后清理Eden和刚才使用的Survivor空间。当Survivor空间不够时，那么这些对象直接通过分配担保机制进入老年代。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;#888888&quot;&gt;本文介绍java垃圾回收的基本算法,引用计数法、标记-清除法、复制法、标记-整理法、分代收集法。&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>深入理解hashMap</title>
    <link href="http://yoursite.com/2018/03/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
    <id>http://yoursite.com/2018/03/30/深入理解HashMap/</id>
    <published>2018-03-30T09:23:19.552Z</published>
    <updated>2018-03-30T09:29:55.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解hashMap"><a href="#深入理解hashMap" class="headerlink" title="深入理解hashMap"></a>深入理解hashMap</h1><h2 id="hashMap简介"><a href="#hashMap简介" class="headerlink" title="hashMap简介"></a>hashMap简介</h2><p>HashMap是一种以K-V存储的集合对象，结合了数组结构查询快和链表结构插入、删除快的特点；它允许key、value为null<br>是一种无序并且线程不安全的集合对象。</p><h2 id="hashMap初始化"><a href="#hashMap初始化" class="headerlink" title="hashMap初始化"></a>hashMap初始化</h2><p>hashMap的实例有两个参数影响其性能:”初始容量”和”加载因子”。容量是哈希表中桶的数量，初始容量知识哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的元素数超出了加载因子与当前容量的乘积时，就要对这个哈希进行rehash，从而哈希表将具有两倍左右的桶数。默认的加载因子为0.75，这是在速度和空间上的折中，加载因子过高减少空间但也增加了查询速度。在设置初始容量时应该考虑元素的总数，以此来减少rehash的次数。当初始容量大于总元素数除以加载因子时就不会发生rehash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 默认构造函数。</span><br><span class="line">HashMap()</span><br><span class="line"></span><br><span class="line">// 指定“容量大小”的构造函数</span><br><span class="line">public HashMap(int initialCapacity)</span><br><span class="line"></span><br><span class="line">// 指定“容量大小”和“加载因子”的构造函数</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor)</span><br><span class="line"></span><br><span class="line">// 包含“子Map”的构造函数</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m)</span><br></pre></td></tr></table></figure><p>我们来看一下第三个构造函数代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现传入了参数并没有给我们初始化，那是不是就说明我们传入的参数是无效的呢？其实这一点是hashMap设计聪明的地方，如果初始化一个hashMap，而不用岂不是占用了空间资源，实际上当我们调用了put方法便会实现初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">//table并没有改变，这里为true</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  private void inflateTable(int toSize) &#123;</span><br><span class="line">      // Find a power of 2 &gt;= toSize</span><br><span class="line">      int capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">//把threshold设置为最小大于输入容量的2的N次放</span><br><span class="line">      threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">      table = new Entry[capacity];</span><br><span class="line">      initHashSeedAsNeeded(capacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里会把threshold设置为最小的大于输入容量的2的N次方，这也是之前提的，当rehash时，大约为2倍而不是正好2倍就在于次。而这样做也是另一个hashMap聪明的地方。<br>前面提到过hashMap的数据结构是数组和链表的结合，所以要尽量让元素分布的均匀一些，我们首先想到的便是取模，但是这样做运算消耗比较大，而它是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处就相当于对它进行取模，具体的大家可以进行一下测试，当数组长度为2的N次方和非2的N次方时的对比，会发现当为2的N次方时分布更加均匀。</p><h2 id="hash碰撞"><a href="#hash碰撞" class="headerlink" title="hash碰撞"></a>hash碰撞</h2><p>解决hash冲突有拉链法、开放地址法。而hashMap解决hash碰撞使用的是拉链法,当我们往hashMap中put元素的时候，先根据key的hash值，找到这个元素在数组中的位置，然后把它放到对应的位置中。如果当前元素所在的位置上已经有其他元素，则这个位置将会以链表的形式存放，后加入的放在链头，先加入的放在链尾。当需要从hashMap获取元素的时候，首先通过key的hash值找到数组中对应的位置，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><h2 id="hashMap结构图"><a href="#hashMap结构图" class="headerlink" title="hashMap结构图"></a>hashMap结构图</h2><p><img src="http://img.blog.csdn.net/20180330153616088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnVnb3U0OTgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="结构图"></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;#888888&quot;&gt;深入理解hashMap原理，分析hashMap源码，以及hashMap设计巧妙的地方。&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql常用搜索引擎</title>
    <link href="http://yoursite.com/2018/03/28/mysql%E5%B8%B8%E7%94%A8%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2018/03/28/mysql常用搜索引擎/</id>
    <published>2018-03-28T05:51:51.964Z</published>
    <updated>2018-03-28T05:54:07.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql常用搜索引擎"><a href="#mysql常用搜索引擎" class="headerlink" title="mysql常用搜索引擎"></a>mysql常用搜索引擎</h1><h2 id="innoDB简介"><a href="#innoDB简介" class="headerlink" title="innoDB简介"></a>innoDB简介</h2><p>innoDB引擎，它是一个事务型的引擎，它设计为了处理大量数据提供高性能的服务。它支持事物处理、实现sql标准的四种隔离级、支持行级锁但行级锁并不是决对的、外键以及利用事物日志进行数据的恢复，不支持FULLTEXT类型的索引，清空表时不会新建表而是一行一行删除。适合需要事物，大量数据读写的项目。</p><h2 id="MyISAM简介"><a href="#MyISAM简介" class="headerlink" title="MyISAM简介"></a>MyISAM简介</h2><p>MyISAM引擎是mysql的默认引擎，它可以高性能的读取。表级别锁，记录了全表的行数，当使用count时不会进行全表扫描，不支持事物，对表进行insert和update时会对表进行锁定，发生故障无法恢复。适合不需要事物，读取频繁，插入少的项目。</p><h2 id="引擎对比"><a href="#引擎对比" class="headerlink" title="引擎对比"></a>引擎对比</h2><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">innoDB</th><th style="text-align:center">MyISAM </th></tr></thead><tbody><tr><td style="text-align:center">主外键</td><td style="text-align:center">O</td><td style="text-align:center">X</td></tr><tr><td style="text-align:center">事物</td><td style="text-align:center">O</td><td style="text-align:center">X</td></tr><tr><td style="text-align:center">锁</td><td style="text-align:center">行级，操作时指锁定一行，适合高并发</td><td style="text-align:center">表级，操作时会锁住整张表</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">既缓存索引又缓存数据，对内存要求高，内存影响性能</td><td style="text-align:center">只缓存索引不缓存数据</td></tr><tr><td style="text-align:center">表空间</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">关注点</td><td style="text-align:center">事物</td><td style="text-align:center">性能</td></tr></tbody></table><h2 id="innoDB死锁"><a href="#innoDB死锁" class="headerlink" title="innoDB死锁"></a>innoDB死锁</h2><p>innoDB是行级别锁，但mysql行级锁不是锁主整行，而是锁主索引，索引又分为主键索引和非主键索引，当操作了主键，则锁住主键，当操作了非主键索引，则会先锁住这个非主键索引再去锁住主键。这样就造成了会出现死锁的现象。</p><h2 id="查询时MyISAM为什么比innoDB快"><a href="#查询时MyISAM为什么比innoDB快" class="headerlink" title="查询时MyISAM为什么比innoDB快"></a>查询时MyISAM为什么比innoDB快</h2><p>innoDB既要缓存索引又要缓存数据，而MyISAM只缓存索引。<br>innoDB寻址是先映射到块再映射到行，而MyISAM直接映射到文件的偏移量。<br>innoDB要维护多版本并发控制。<br>总而言之innoDB需要维护的东西比MyISAM多。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;#888888&quot;&gt;本文介绍mysql的两种常用搜索引擎innoDB和MyISAM，并比较两种的不同以及适用场景。&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="搜索引擎" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>让线程更安全</title>
    <link href="http://yoursite.com/2018/03/23/%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%9B%B4%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/03/23/让线程更安全/</id>
    <published>2018-03-23T09:08:21.159Z</published>
    <updated>2018-03-23T09:13:52.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="让线程更安全"><a href="#让线程更安全" class="headerlink" title="让线程更安全"></a>让线程更安全</h1><p>&nbsp;&nbsp;在多线程编程中要时刻保持着三个核心的概念</p><ol><li>原子性：<br>&nbsp;&nbsp;原子是不可分的，原子性通俗的讲就是一次操作包含有多个步骤，这些步骤要么全部生效，要么全都无效。这一点和数据库事物的原子性概念差不多。<a id="more"></a></li><li>可见性：<br>&nbsp;&nbsp;当多个线程并发访问同一个共享变量时，一个线程对共享变量的修改，其他线程能够立即看到。</li><li>顺序性：<br>&nbsp;&nbsp;顺序性，指的是按照代码的先后顺序执行。但实际上JVM真正的在执行代码时，并不会保证完全按顺序执行，它为了提高执行效率会对代码进行优化，按照更高效的顺序执行。但它会保证程序最终的执行结果和按代码顺序执行时的结果保持一致的。</li></ol><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p> &nbsp;&nbsp;常用的方法便是锁和同步代码块。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p> &nbsp;&nbsp;使用锁，保证同一时间只有一个线程可以使用得到锁，保证一个线程能够执行申请锁和释放锁之间的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void testLock()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        int a = 1 ;</span><br><span class="line">        int b = 2 ;</span><br><span class="line">        int c = a + b ;</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;为了确保可以释放锁，需要把lock.unlock()放到finally中</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>&nbsp;&nbsp;和锁类似，都是实现资源的排他性，同一时间只会被一个线程执行，保证了代码段的原子性。同时也牺牲了性能。同步代码块使用非静态同步方法时，锁住的是当前实例，使用静态同步方法时，锁住的是该类的Class对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void testLock()&#123;</span><br><span class="line">    Object object = new Object();</span><br><span class="line">    synchronized (object)&#123;</span><br><span class="line">        int a = 1 ;</span><br><span class="line">        int b = 2 ;</span><br><span class="line">        int c = a + b ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h3><p>&nbsp;&nbsp;<a href="https://blog.csdn.net/zhangerqing/article/details/43057799" target="_blank" rel="noopener">https://blog.csdn.net/zhangerqing/article/details/43057799</a></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>&nbsp;&nbsp;Java提供了volatile保证了可见性。使用volatile修饰变量时，对该变量的修改会立刻更新到内存，其他线程读取时就会获得最新的值。</p><h2 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h2><p>&nbsp;&nbsp;JVM通过happens-before原则隐性地保证顺序性。hapens-before原则：</p><ol><li>传递规则：动作1发生在动作2之前，动作2发生在动作3之前，则动作1肯定发生在动作3之前。</li><li>锁定规则：unlock肯定会在下一个对同一个锁的lock之前发生。</li><li>volatile原则：对被volatile修饰的写操作发生在后面对这个变量的读操作之前。</li><li>程序次序规则：同一个线程内，按代码顺序执行</li><li>线程启动规则：Thread对象的start方法比该线程所有动作都先发生。</li><li>线程终结原则：线程终止检测最后发生。</li><li>线程中断规则： 对线程interrupt()方法的调用先发生于对该中断异常的获取。</li><li>对象终结规则：一个对象构造先于它的finalize发生。</li></ol><h1 id="拓展sleep和wait区别"><a href="#拓展sleep和wait区别" class="headerlink" title="拓展sleep和wait区别"></a>拓展sleep和wait区别</h1><p>&nbsp;&nbsp;wait是object类的方法，会释放锁，让出cpu，可以使用notify或notifyAll方法激活，再次获得锁便可以继续执行。sleep是线程静态方法不会释放锁。</p><p align="right"><font color="#888">后续补充。。。。</font></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;#888888&quot;&gt;本文介绍使线程安全应注意的事项，在多线程编程中要时刻注意原子性、可见性、顺序性，以及实现的代码。同时拓展了一些wait、sleep&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>初识多线程</title>
    <link href="http://yoursite.com/2018/03/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/22/java多线程/</id>
    <published>2018-03-22T11:46:05.426Z</published>
    <updated>2018-03-23T09:16:44.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ol><li>新建状态:<br>&ensp;&ensp;&ensp;&ensp;顾名思义，就是新建一个线程。处于新建状态的线程有自己的内存空间，通过调用start方法进入就绪状态。<a id="more"></a></li><li>就绪状态:<br>&ensp;&ensp;&ensp;&ensp;这时已经具备了运行条件，但还没有分配到CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</li><li>运行状态:<br>&ensp;&ensp;&ensp;&ensp;运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。<br>&ensp;&ensp;&ensp;&ensp;此时线程失去了cpu资源，就会又从运行状态变为就绪状态。当发生如下情况是，线程会从运行状态变为阻塞状态：<br>①、线程调用sleep方法主动放弃所占用的系统资源<br>②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞<br>③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有<br>④、线程在等待某个通知（notify）<br>⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。<br>当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。</li><li>阻塞状态：<br>&ensp;&ensp;&ensp;&ensp;在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。</li><li>死亡状态：<br>&ensp;&ensp;&ensp;&ensp;当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li></ol><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><p>java中实现多线程的方式有四种：<br>     &ensp;&ensp;1. 继承Thread类，重写run方法<br>     &ensp;&ensp;2. 实现Runnable接口，重写run方法。<br>     &ensp;&ensp;3. 通过Callable和FutureTask创建线程。<br>     &ensp;&ensp;4. 通过线程池创建线程<br> &ensp;&ensp;前两种可以归为一类，都是通过重写run方法，run方法的返回类型为void，无返回值。由于java单继承，类继承了Thread，会导致无法继承其他类，同时继承Thread类实际上是无法达到资源共享的目的的，所以在实际开发中更多的是实现Runnable接口。后面两种有返回值可以归结为一类。<br><br><br> 方法1：继承Thread类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.thread;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 继承Thread类</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午11:06 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    volatile int i ;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (; i &lt; 10 ; i ++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;执行了第&quot;+i+&quot;次&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        ThreadTest threadTest = new ThreadTest();</span><br><span class="line">        ThreadTest threadTest1 = new ThreadTest();</span><br><span class="line">        ThreadTest threadTest2 = new ThreadTest();</span><br><span class="line">        ThreadTest threadTest3 = new ThreadTest();</span><br><span class="line">        threadTest.start();</span><br><span class="line">        threadTest1.start();</span><br><span class="line">        threadTest2.start();</span><br><span class="line">        threadTest3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2：实现Runnable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.runnable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 实现runnable接口</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午10:56 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class RunnableTest implements Runnable&#123;</span><br><span class="line">    int i;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (; i &lt; 10 ; i ++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行了第&quot;+i+&quot;次&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        RunnableTest runnableTest = new RunnableTest();</span><br><span class="line">        Thread thread = new Thread(runnableTest,&quot;线程&quot;);</span><br><span class="line">        Thread thread1 = new Thread(runnableTest,&quot;线程1&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3：实现Callable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.callable;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 实现callable接口</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午11:09 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class CallableTest implements Callable &#123;</span><br><span class="line"></span><br><span class="line">    int i ;</span><br><span class="line"></span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line">        for (; i &lt; 10 ; i ++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;执行了第&quot;+i+&quot;次&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Thread.currentThread().getName()+&quot;执行完毕&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        CallableTest callableTest = new CallableTest();</span><br><span class="line">        FutureTask futureTask = new FutureTask(callableTest);</span><br><span class="line">        FutureTask futureTask1 = new FutureTask(callableTest);</span><br><span class="line">        new Thread(futureTask,&quot;aa&quot;).start();</span><br><span class="line">        new Thread(futureTask1,&quot;bb&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">            System.out.println(futureTask1.get());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.Thread.ThreadPool;</span><br><span class="line"></span><br><span class="line">import com.zhang.Thread.callable.CallableTest;</span><br><span class="line">import com.zhang.Thread.runnable.RunnableTest;</span><br><span class="line">import com.zhang.Thread.thread.ThreadTest;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : 线程池</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 上午10:55 2018/3/20</span><br><span class="line"> */</span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line"></span><br><span class="line">    static ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        //官方推荐，会自动创建 销毁</span><br><span class="line">        executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(new ThreadTest());</span><br><span class="line">        executorService.execute(new RunnableTest());</span><br><span class="line">        FutureTask futureTask = new FutureTask(new CallableTest());</span><br><span class="line">        executorService.execute(futureTask);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //关闭</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;执行后会发现结果有时候会和自己想的有些差别，这就是线程不安全的问题。下一篇会详解一下线程安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;#888888&quot;&gt;本文介绍线程的生命周期：新建状态、就绪状态、运行状态、阻塞状态、死亡状态；以及实现多线程的四种方式：继承Thread类、实现Runnable类、实现Callable、通过线程池创建，其中前两种无返回值，后两种有返回值。&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2018/03/21/java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/21/java代理模式/</id>
    <published>2018-03-21T08:13:33.753Z</published>
    <updated>2018-03-23T09:14:53.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><p>&emsp;&emsp;代理（Proxy）是一种常用的设计模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。目的就是在不需要修改原有的代码情况下扩展原功能。<br><a id="more"></a></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>1.创建服务类接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public interface UserInterface &#123;</span><br><span class="line"></span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.实现服务接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class UserImpl implements UserInterface&#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;执行User的save方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class UserProxy implements UserInterface &#123;</span><br><span class="line">    private UserImpl target;</span><br><span class="line">    public UserProxy(UserImpl target) &#123;</span><br><span class="line">        this.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;开始执行代理类&quot;);</span><br><span class="line">        target.save();</span><br><span class="line">        System.out.println(&quot;结束执行代理类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.可以来测试啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        UserImpl user = new UserImpl();</span><br><span class="line">        UserProxy userProxy = new UserProxy(user);</span><br><span class="line">        userProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理总结：<br>&emsp;&emsp;可以做到不修改原服务代码的情况下对目标对象进行功能的扩展，但为们需要为每一个服务都创建一个代理类，工作量有些大，同时接口发生改变，代理类也需要改变。<br><br></p><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>&emsp;&emsp;在动态代理中我们只需要写一个动态处理器。JDK运行时为我们动态创建代理对象。<br>1.创建目标对象接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.创建目标对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;执行UserServiceImpl的add方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.编写jdk动态处理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : jdk动态代理</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 下午4:13 2018/3/19</span><br><span class="line"> */</span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行目标对象方法</span><br><span class="line">     * @param proxy</span><br><span class="line">     * @param method</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行目标方法前&quot;);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;执行目标方法后&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取目标对象的代理对象</span><br><span class="line">     * @return 代理对象</span><br><span class="line">     */</span><br><span class="line">    public Object getProxy() &#123;</span><br><span class="line">        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                this.target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.编写测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_02 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //实例化目标对象</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        //实例化Invocation</span><br><span class="line">        MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);</span><br><span class="line">        //根据目标生成代理对象</span><br><span class="line">        UserService proxy = (UserService) invocationHandler.getProxy();</span><br><span class="line">        //调用代理对象方法</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance()方法接受的三个参数：<br>&emsp;&emsp;1.当前目标对象使用的类加载器<br>&emsp;&emsp;2.制定目标对象实现的接口类型<br>&emsp;&emsp;3.指定动态处理器，执行目标对象时触发处理器的方法<br>jdk动态代理总结：<br>&emsp;&emsp;对比静态代理，动态代理减少了为们开发任务，同时降低了对接口的耦合度。遗憾的是只能对实现了接口的类进行代理。</p><h2 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h2><p>&emsp;&emsp;由于Jdk动态代理只能对实现了接口的类进行代理。那么对于没有接口的类，就需要cglib了。<br>1.引入jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.创建目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;执行User的add方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.创建cglib代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class UserCglib implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line">    /**</span><br><span class="line">     * 创建代理对象</span><br><span class="line">     * @param target</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object getInstance(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">      enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        //回调方法</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 回调方法</span><br><span class="line">     * @param o</span><br><span class="line">     * @param method</span><br><span class="line">     * @param objects</span><br><span class="line">     * @param methodProxy</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行目标方法之前&quot;);</span><br><span class="line">        methodProxy.invokeSuper(o,objects);</span><br><span class="line">        System.out.println(&quot;执行目标方法之后&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        UserCglib userCglib = new UserCglib();</span><br><span class="line">        User user = (User)userCglib.getInstance(new User());</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cglib代理总结：<br>&emsp;&emsp;cglib创建的动态代理对象比JDK创建的性能更高，代价是创建时花费的时间也多的多。所以对于单例对象，采用cglib更合适。cglib采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p><h2 id="拓展Spring-aop"><a href="#拓展Spring-aop" class="headerlink" title="拓展Spring aop"></a>拓展Spring aop</h2><p>&emsp;&emsp;Spring 默认采用JDK动态代理，如果要被代理的对象不是实现类，那么Spring会强制使用CGLib来实现动态代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- 切面详细配置 --&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></p><p>target=true为cglib代理。默认为false</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;font color=&quot;#888888&quot;&gt;本文将介绍代理模式的三种实现方式：静态代理、jdk动态代理、cglib代理，以及每种方式的实现和优缺点并进行对比。同时拓展了Spring Aop&lt;/font&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
