<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风忆</title>
  
  <subtitle>时间未动，动的是我们</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-21T08:27:13.118Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java代理模式</title>
    <link href="http://yoursite.com/2018/03/21/java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/21/java代理模式/</id>
    <published>2018-03-21T08:13:33.753Z</published>
    <updated>2018-03-21T08:27:13.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h1><p>&emsp;&emsp;代理（Proxy）是一种常用的设计模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。目的就是在不需要修改原有的代码情况下扩展原功能。<br><a id="more"></a></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>1.创建服务类接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public interface UserInterface &#123;</span><br><span class="line"></span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.实现服务接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class UserImpl implements UserInterface&#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;执行User的save方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class UserProxy implements UserInterface &#123;</span><br><span class="line">    private UserImpl target;</span><br><span class="line">    public UserProxy(UserImpl target) &#123;</span><br><span class="line">        this.target = target ;</span><br><span class="line">    &#125;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;开始执行代理类&quot;);</span><br><span class="line">        target.save();</span><br><span class="line">        System.out.println(&quot;结束执行代理类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.可以来测试啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.staticProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_01 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        UserImpl user = new UserImpl();</span><br><span class="line">        UserProxy userProxy = new UserProxy(user);</span><br><span class="line">        userProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理总结：<br>&emsp;&emsp;可以做到不修改原服务代码的情况下对目标对象进行功能的扩展，但为们需要为每一个服务都创建一个代理类，工作量有些大，同时接口发生改变，代理类也需要改变。<br><br></p><h2 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>&emsp;&emsp;在动态代理中我们只需要写一个动态处理器。JDK运行时为我们动态创建代理对象。<br>1.创建目标对象接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.创建目标对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;执行UserServiceImpl的add方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.编写jdk动态处理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Description : jdk动态代理</span><br><span class="line"> * @Author : zhangMing</span><br><span class="line"> * @Date : Created in 下午4:13 2018/3/19</span><br><span class="line"> */</span><br><span class="line">public class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行目标对象方法</span><br><span class="line">     * @param proxy</span><br><span class="line">     * @param method</span><br><span class="line">     * @param args</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行目标方法前&quot;);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;执行目标方法后&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取目标对象的代理对象</span><br><span class="line">     * @return 代理对象</span><br><span class="line">     */</span><br><span class="line">    public Object getProxy() &#123;</span><br><span class="line">        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                this.target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.编写测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.jdkProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_02 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        //实例化目标对象</span><br><span class="line">        UserService userService = new UserServiceImpl();</span><br><span class="line">        //实例化Invocation</span><br><span class="line">        MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);</span><br><span class="line">        //根据目标生成代理对象</span><br><span class="line">        UserService proxy = (UserService) invocationHandler.getProxy();</span><br><span class="line">        //调用代理对象方法</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy.newProxyInstance()方法接受的三个参数：<br>&emsp;&emsp;1.当前目标对象使用的类加载器<br>&emsp;&emsp;2.制定目标对象实现的接口类型<br>&emsp;&emsp;3.指定动态处理器，执行目标对象时触发处理器的方法<br>jdk动态代理总结：<br>&emsp;&emsp;对比静态代理，动态代理减少了为们开发任务，同时降低了对接口的耦合度。遗憾的是只能对实现了接口的类进行代理。</p><p>##cglib代理<br>&emsp;&emsp;由于Jdk动态代理只能对实现了接口的类进行代理。那么对于没有接口的类，就需要cglib了。<br>1.引入jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.创建目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;执行User的add方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.创建cglib代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class UserCglib implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line">    /**</span><br><span class="line">     * 创建代理对象</span><br><span class="line">     * @param target</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object getInstance(Object target)&#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">      enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">        //回调方法</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 回调方法</span><br><span class="line">     * @param o</span><br><span class="line">     * @param method</span><br><span class="line">     * @param objects</span><br><span class="line">     * @param methodProxy</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;执行目标方法之前&quot;);</span><br><span class="line">        methodProxy.invokeSuper(o,objects);</span><br><span class="line">        System.out.println(&quot;执行目标方法之后&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建测试类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.proxy.cglibProxy;</span><br><span class="line"></span><br><span class="line">public class Test_20180319_03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line">        UserCglib userCglib = new UserCglib();</span><br><span class="line">        User user = (User)userCglib.getInstance(new User());</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cglib代理总结：<br>&emsp;&emsp;cglib创建的动态代理对象比JDK创建的性能更高，代价是创建时花费的时间也多的多。所以对于单例对象，采用cglib更合适。cglib采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p><h2 id="拓展Spring-aop"><a href="#拓展Spring-aop" class="headerlink" title="拓展Spring aop"></a>拓展Spring aop</h2><p>&emsp;&emsp;Spring 默认采用JDK动态代理，如果要被代理的对象不是实现类，那么Spring会强制使用CGLib来实现动态代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">&lt;!-- 切面详细配置 --&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></p><p>target=true为cglib代理。默认为false</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java代理模式&quot;&gt;&lt;a href=&quot;#Java代理模式&quot; class=&quot;headerlink&quot; title=&quot;Java代理模式&quot;&gt;&lt;/a&gt;Java代理模式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;代理（Proxy）是一种常用的设计模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。目的就是在不需要修改原有的代码情况下扩展原功能。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
